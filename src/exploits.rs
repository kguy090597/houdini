// SPDX-License-Identifier: Apache-2.0
//
// Houdini  A container escape artist
// Copyright (c) 2022  William Findlay
//
// February 25, 2022  William Findlay  Created this.
//

//! This module encapsulates container exploit payloads as well as operations to be run
//! on the host system to bootstrap container exploits.

use std::{
    io::{Cursor, Read},
    os::unix::process::ExitStatusExt as _,
};

use crate::CONFIG;
use anyhow::{bail, Result};
use docker_api::{api::ContainerCreateOpts, Docker};
use serde::{Deserialize, Serialize};

fn default_setup_failure() -> ExploitStatus {
    ExploitStatus::SetupFailure
}

fn default_true() -> bool {
    true
}

fn default_false() -> bool {
    false
}

/// A plan for running and verifying a container exploit.
#[derive(Debug, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct Plan {
    steps: Vec<Step>,
}

impl Plan {
    /// Run every step of the exploit plan, returning a final status in the end.
    /// If any step returns a final status, we return that status early.
    pub async fn run(&self) -> ExploitStatus {
        let mut status = ExploitStatus::Undecided;
        for step in &self.steps {
            status = step.run().await;
            if status.is_final() {
                break;
            }
        }
        status
    }
}

/// An individual step in an exploit plan.
#[derive(Debug, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct ShellCommand {
    pub command: String,
    pub args: Vec<String>,
}

/// An individual step in an exploit plan.
#[derive(Debug, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
enum Step {
    /// Spawn a container using the docker api.
    SpawnContainer {
        /// Name to assign the container. This is done using the docker api, so commands
        /// like `docker exec -it <name> <command>` will work.
        name: String,
        /// Container image to use for the spawned container.
        image: String,
        /// Pull the image if it does not exist on the host.
        #[serde(default = "default_true")]
        pull_image: bool,
        /// Command to run in the container.
        cmd: Option<String>,
        /// Docker volumes for the container.
        volumes: Vec<String>,
        /// Spawn the container with extra privileges.
        #[serde(default = "default_false")]
        privileged: bool,
        /// Failure mode for when this step fails. Default is SetupFailure.
        #[serde(default = "default_setup_failure")]
        failure: ExploitStatus,
        /// Success mode for when this step fails. Default is Undecided.
        #[serde(default)]
        success: ExploitStatus,
    },
    /// Kill a container using the docker api.
    KillContainer {
        /// Name of the container to kill.
        name: String,
        /// Failure mode for when this step fails. Default is Undecided.
        #[serde(default)]
        failure: ExploitStatus,
        /// Success mode for when this step fails. Default is Undecided.
        #[serde(default)]
        success: ExploitStatus,
    },
    /// Run a command or commands on the host.
    Host {
        /// Script to run on the host. A non-zero exit status triggers `failure`,
        /// while a zero exit status triggers `success`.
        script: Vec<ShellCommand>,
        /// Failure mode for when this step fails. Default is Undecided.
        #[serde(default)]
        failure: ExploitStatus,
        /// Success mode for when this step fails. Default is Undecided.
        #[serde(default)]
        success: ExploitStatus,
    },
    /// Run a command in a spawned container. This is done using the docker api.
    Container {
        /// Name of the container to run the command in. Must be the name of a previously
        /// spawned container.
        name: String,
        /// Script to run in the container. A non-zero exit status triggers `failure`,
        /// while a zero exit status triggers `success`.
        script: Vec<ShellCommand>,
        /// Should we run the commands with elevated privileges in the container?
        #[serde(default = "default_false")]
        privileged: bool,
        /// Should we spawn and attach a TTY for these commands?
        #[serde(default = "default_true")]
        tty: bool,
        /// Failure mode for when this step fails. Default is Undecided.
        #[serde(default)]
        failure: ExploitStatus,
        /// Success mode for when this step fails. Default is Undecided.
        #[serde(default)]
        success: ExploitStatus,
    },
}

impl Step {
    /// Returns the failure mode of the step.
    fn failure_mode(&self) -> ExploitStatus {
        match self {
            Step::SpawnContainer { failure, .. } => *failure,
            Step::KillContainer { failure, .. } => *failure,
            Step::Host { failure, .. } => *failure,
            Step::Container { failure, .. } => *failure,
        }
    }

    /// Returns the success mode of the step.
    fn success_mode(&self) -> ExploitStatus {
        match self {
            Step::SpawnContainer { success, .. } => *success,
            Step::KillContainer { success, .. } => *success,
            Step::Host { success, .. } => *success,
            Step::Container { success, .. } => *success,
        }
    }

    /// The internal implementation of `Step::run()`.
    async fn do_run(&self) -> Result<()> {
        match self {
            Step::SpawnContainer {
                name,
                image,
                cmd,
                volumes,
                privileged,
                ..
            } => {
                let client = Docker::unix(&CONFIG.docker.socket);

                let mut opts_builder = ContainerCreateOpts::builder(image)
                    .name(name)
                    .volumes(volumes)
                    .privileged(*privileged)
                    .auto_remove(true);

                if let Some(cmd) = cmd {
                    opts_builder = opts_builder.cmd(cmd.split_whitespace())
                }

                let opts = opts_builder.build();
                let container = client.containers().create(&opts).await?;
                container.start().await?;

                Ok(())
            }
            Step::KillContainer { name, .. } => {
                let client = Docker::unix(&CONFIG.docker.socket);

                let container = client.containers().get(name);
                container.kill(None).await?;

                Ok(())
            }
            Step::Host { script, .. } => {
                use std::process::{Command, Stdio};

                for cmd in script {
                    match Command::new(&cmd.command)
                        .stdout(Stdio::piped())
                        .stderr(Stdio::piped())
                        .args(&cmd.args)
                        .output()
                    {
                        Ok(out) => {
                            let status = out.status;
                            if !status.success() {
                                let stdout = String::from_utf8(out.stdout).unwrap_or("".into());
                                let stderr = String::from_utf8(out.stderr).unwrap_or("".into());

                                let cmd = std::iter::once(&cmd.command)
                                    .chain(&cmd.args)
                                    .fold(String::new(), |s, a| s + " " + a);
                                tracing::warn!("command {} failed", cmd);
                                tracing::warn!("stdout -----------------");
                                tracing::warn!("{}", stdout);
                                tracing::warn!("stderr -----------------");
                                tracing::warn!("{}", stderr);

                                match status.code() {
                                    Some(code) => bail!("command failed with exit code: {}", code),
                                    None => {
                                        bail!(
                                            "command exited with signal: {}",
                                            status
                                                .signal()
                                                .expect("No signal or exit code for process!?")
                                        )
                                    }
                                }
                            }
                            continue;
                        }
                        Err(e) => {
                            return Err(anyhow::Error::from(e).context("failed to run command"))
                        }
                    }
                }

                Ok(())
            }
            Step::Container {
                name,
                script,
                privileged,
                tty,
                ..
            } => {
                use crate::docker::{Command, ExitCode};

                for cmd in script {
                    let mut stdout_capture = Cursor::new(Vec::new());
                    let mut stderr_capture = Cursor::new(Vec::new());

                    match Command::new(name, &cmd.command)
                        .args(&cmd.args)
                        .stdout(&mut stdout_capture)
                        .stderr(&mut stderr_capture)
                        .tty(*tty)
                        .privileged(*privileged)
                        .status()
                        .await
                    {
                        Ok(ExitCode(0)) => continue,
                        Ok(code) => {
                            let mut stdout = String::new();
                            let mut stderr = String::new();
                            let _ = stdout_capture.read_to_string(&mut stdout);
                            let _ = stderr_capture.read_to_string(&mut stderr);

                            let cmd = std::iter::once(&cmd.command)
                                .chain(&cmd.args)
                                .fold(String::new(), |s, a| s + " " + a);
                            tracing::warn!("command {} failed", cmd);
                            tracing::warn!("stdout -----------------");
                            tracing::warn!("{}", stdout);
                            tracing::warn!("stderr -----------------");
                            tracing::warn!("{}", stderr);

                            bail!("command failed with exit code: {}", code.0)
                        }
                        Err(e) => return Err(e.context("failed to run command in container")),
                    }
                }

                Ok(())
            }
        }
    }

    /// Run the step and return either its `Step::success_mode()` or
    /// `Step::failure_mode()` depending on whether it succeeded or not.
    pub async fn run(&self) -> ExploitStatus {
        match self.do_run().await {
            Ok(_) => {
                let status = self.success_mode();
                tracing::info!(step = ?self, status = ?status, "step succeeded");
                status
            }
            Err(e) => {
                let status = self.failure_mode();
                tracing::info!(error = ?e, step = ?self, status = ?status, "step failed");
                status
            }
        }
    }
}

#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone, Copy)]
#[serde(rename_all = "camelCase")]
pub enum ExploitStatus {
    /// The status of the exploit test is undecided.
    Undecided,
    /// Setup has failed.
    /// This is a final status that stops the plan.
    SetupFailure,
    /// The exploit has succeeded.
    /// This is a final status that stops the plan.
    ExploitSuccess,
    /// The exploit has failed.
    /// This is a final status that stops the plan.
    ExploitFailure,
}

impl ExploitStatus {
    pub fn is_final(&self) -> bool {
        match self {
            ExploitStatus::Undecided => false,
            ExploitStatus::SetupFailure => true,
            ExploitStatus::ExploitSuccess => true,
            ExploitStatus::ExploitFailure => true,
        }
    }
}

impl Default for ExploitStatus {
    fn default() -> Self {
        ExploitStatus::Undecided
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tracing_test::traced_test;

    #[test]
    #[traced_test]
    fn test_yaml_plan_serde_smoke() {
        use serde_yaml::{from_str, to_string};

        let yaml = r#"
            steps:
            - spawnContainer:
                name: bash
                image: bash
            - host:
                script:
                - command: docker
                  args: ["cp", "/etc/passwd", "bash:/passwd"]
                failure: setupFailure
            - container:
                name: bash
                script:
                - command: cat
                  args: ["/passwd"]
                failure: exploitFailure
                success: exploitSuccess
            "#;

        let plan: Plan = from_str(yaml).expect("should deserialize");
        println!("{plan:#?}");

        let yaml = to_string(&plan).expect("should serialize");
        let plan2: Plan = from_str(&yaml).expect("should deserialize back");

        assert_eq!(plan, plan2, "deserialized structs should be the same");
    }

    #[tokio::test]
    #[traced_test]
    async fn test_spawn_container() {
        use serde_yaml::from_str;

        let yaml = r#"
            steps:
            - spawnContainer:
                name: bash
                image: bash
                cmd: sleep infinity
            - host:
                script:
                - command: echo
                  args: ["hello"]
                - command: echo
                  args: ["goodbye"]
                failure: exploitFailure
            - container:
                name: bash
                script:
                - command: echo
                  args: ["hello"]
                - command: echo
                  args: ["goodbye"]
                failure: exploitFailure
                success: exploitSuccess
            "#;

        let plan: Plan = from_str(yaml).expect("should deserialize");
        let status = plan.run().await;
        assert!(matches!(status, ExploitStatus::ExploitSuccess));
    }
}
