// SPDX-License-Identifier: Apache-2.0
//
// Houdini  A container escape artist
// Copyright (c) 2022  William Findlay
//
// February 25, 2022  William Findlay  Created this.
//

//! This module encapsulates container exploit payloads as well as operations to be run
//! on the host system to bootstrap container exploits.

use std::process::Command;

use crate::CONFIG;
use anyhow::{bail, Context, Result};
use docker_api::{api::ContainerCreateOpts, Docker, Exec, ExecContainerOpts};
use futures::StreamExt;
use serde::{Deserialize, Serialize};

pub mod container;
pub mod host;

fn default_setup_failure() -> ExploitStatus {
    ExploitStatus::SetupFailure
}

fn default_bin_sh() -> String {
    "/bin/sh -c".into()
}

/// A plan for running and verifying a container exploit.
#[derive(Debug, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct Plan {
    steps: Vec<Step>,
}

impl Plan {
    /// Run every step of the exploit plan, returning a final status in the end.
    /// If any step returns a final status, we return that status early.
    pub async fn run(&self) -> ExploitStatus {
        let mut status = ExploitStatus::Undecided;
        for step in &self.steps {
            status = step.run().await;
            if status.is_final() {
                break;
            }
        }
        status
    }
}

/// An individual step in an exploit plan.
#[derive(Debug, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
enum Step {
    /// Spawn a container using the docker api.
    SpawnContainer {
        /// Name to assign the container. This is done using the docker api, so commands
        /// like `docker exec -it <name> <command>` will work.
        name: String,
        /// Container image to use for the spawned container.
        image: String,
        /// Command to run in the container.
        cmd: Option<String>,
        /// Failure mode for when this step fails. Default is SetupFailure.
        #[serde(default = "default_setup_failure")]
        failure: ExploitStatus,
        /// Success mode for when this step fails. Default is Undecided.
        #[serde(default)]
        success: ExploitStatus,
    },
    /// Kill a container using the docker api.
    KillContainer {
        /// Name of the container to kill.
        name: String,
        /// Failure mode for when this step fails. Default is Undecided.
        #[serde(default)]
        failure: ExploitStatus,
        /// Success mode for when this step fails. Default is Undecided.
        #[serde(default)]
        success: ExploitStatus,
    },
    /// Run a command on the host.
    Host {
        /// Command to use for the shell that runs `script`. Must exist on the host and
        /// be capable of running scripts. Default is `/bin/sh -c`.
        #[serde(default = "default_bin_sh")]
        shell: String,
        /// Script to run on the host. A non-zero exit status triggers `failure`,
        /// while a zero exit status triggers `success`.
        script: String,
        /// Failure mode for when this step fails. Default is Undecided.
        #[serde(default)]
        failure: ExploitStatus,
        /// Success mode for when this step fails. Default is Undecided.
        #[serde(default)]
        success: ExploitStatus,
    },
    /// Run a command in a spawned container. This is done using the docker api.
    Container {
        /// Name of the container to run the command in. Must be the name of a previously
        /// spawned container.
        name: String,
        /// Command to use for the shell that runs `script`. Must exist in the container and
        /// be capable of running scripts. Default is `/bin/sh -c`.
        #[serde(default = "default_bin_sh")]
        shell: String,
        /// Script to run in the container. A non-zero exit status triggers `failure`,
        /// while a zero exit status triggers `success`.
        script: String,
        /// Failure mode for when this step fails. Default is Undecided.
        #[serde(default)]
        failure: ExploitStatus,
        /// Success mode for when this step fails. Default is Undecided.
        #[serde(default)]
        success: ExploitStatus,
    },
}

impl Step {
    /// Returns the failure mode of the step.
    fn failure_mode(&self) -> ExploitStatus {
        match self {
            Step::SpawnContainer {
                name: _,
                image: _,
                failure,
                success: _,
                cmd: _,
            } => *failure,
            Step::KillContainer {
                name: _,
                failure,
                success: _,
            } => *failure,
            Step::Host {
                shell: _,
                script: _,
                failure,
                success: _,
            } => *failure,
            Step::Container {
                name: _,
                shell: _,
                script: _,
                failure,
                success: _,
            } => *failure,
        }
    }

    /// Returns the success mode of the step.
    fn success_mode(&self) -> ExploitStatus {
        match self {
            Step::SpawnContainer {
                name: _,
                image: _,
                failure: _,
                success,
                cmd: _,
            } => *success,
            Step::KillContainer {
                name: _,
                failure: _,
                success,
            } => *success,
            Step::Host {
                shell: _,
                script: _,
                failure: _,
                success,
            } => *success,
            Step::Container {
                name: _,
                shell: _,
                script: _,
                failure: _,
                success,
            } => *success,
        }
    }

    /// The internal implementation of `Step::run()`.
    async fn do_run(&self) -> Result<()> {
        match self {
            Step::SpawnContainer {
                name,
                image,
                failure: _,
                success: _,
                cmd,
            } => {
                let client = Docker::unix(&CONFIG.docker.socket);

                let mut opts_builder = ContainerCreateOpts::builder(image)
                    .name(name)
                    .auto_remove(true);

                if let Some(cmd) = cmd {
                    opts_builder = opts_builder.cmd(cmd.split_whitespace())
                }

                let opts = opts_builder.build();
                let container = client.containers().create(&opts).await?;
                container.start().await?;

                Ok(())
            }
            Step::KillContainer {
                name,
                failure: _,
                success: _,
            } => {
                let client = Docker::unix(&CONFIG.docker.socket);

                let container = client.containers().get(name);
                container.kill(None).await?;

                Ok(())
            }
            Step::Host {
                shell,
                script,
                failure: _,
                success: _,
            } => {
                let mut shell: Vec<_> = shell.split_whitespace().into_iter().collect();
                shell.push(script);
                let shell = shell;
                let status = Command::new(shell[0])
                    .args(shell.into_iter().skip(1))
                    .status()
                    .context("failed to run command")?;
                if !status.success() {
                    bail!(
                        "command exited with: {}",
                        status
                            .code()
                            .map(|n| n.to_string())
                            .unwrap_or("Unknown".into())
                    );
                }
                Ok(())
            }
            Step::Container {
                name,
                shell,
                script,
                failure: _,
                success: _,
            } => {
                let client = Docker::unix(&CONFIG.docker.socket);

                let mut shell: Vec<_> = shell.split_whitespace().into_iter().collect();
                shell.push(script);
                let shell = shell;

                let opts = ExecContainerOpts::builder()
                    .cmd(shell)
                    .attach_stdout(true)
                    .attach_stderr(true)
                    .build();

                let mut code: Option<u64> = None;
                let exec = Exec::create(&client, name, &opts).await?;
                let exec_info = exec.inspect().await?;
                tracing::debug!(exec = ?exec_info, "about to run command in container");

                let mut stream = exec.start();
                while let Some(_) = stream.next().await {
                    let exec_info = exec.inspect().await?;
                    code = exec_info.exit_code;
                    if code.is_some() {
                        tracing::debug!(exec = ?exec_info, "command exited");
                        break;
                    }
                }

                match code {
                    None => bail!("command exited with: Unknown"),
                    Some(0) => Ok(()),
                    Some(code) => bail!("command exited with: {}", code),
                }
            }
        }
    }

    /// Run the step and return either its `Step::success_mode()` or
    /// `Step::failure_mode()` depending on whether it succeeded or not.
    pub async fn run(&self) -> ExploitStatus {
        match self.do_run().await {
            Ok(_) => {
                let status = self.success_mode();
                tracing::info!(step = ?self, status = ?status, "step succeeded");
                status
            }
            Err(e) => {
                let status = self.failure_mode();
                tracing::info!(error = ?e, step = ?self, status = ?status, "step failed");
                status
            }
        }
    }
}

#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone, Copy)]
#[serde(rename_all = "camelCase")]
pub enum ExploitStatus {
    /// The status of the exploit test is undecided.
    Undecided,
    /// Setup has failed.
    /// This is a final status that stops the plan.
    SetupFailure,
    /// The exploit has succeeded.
    /// This is a final status that stops the plan.
    ExploitSuccess,
    /// The exploit has failed.
    /// This is a final status that stops the plan.
    ExploitFailure,
}

impl ExploitStatus {
    pub fn is_final(&self) -> bool {
        match self {
            ExploitStatus::Undecided => false,
            ExploitStatus::SetupFailure => true,
            ExploitStatus::ExploitSuccess => true,
            ExploitStatus::ExploitFailure => true,
        }
    }
}

impl Default for ExploitStatus {
    fn default() -> Self {
        ExploitStatus::Undecided
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tracing_test::traced_test;

    #[test]
    #[traced_test]
    fn test_yaml_plan_serde_smoke() {
        use serde_yaml::{from_str, to_string};

        let yaml = r#"
            steps:
            - spawnContainer:
                name: bash
                image: bash
            - host:
                script: |
                    docker cp /etc/passwd bash:/passwd
                failure: setupFailure
            - container:
                name: bash
                shell: /bin/bash
                script: |
                    cat /passwd
                failure: exploitFailure
                success: exploitSuccess
            "#;

        let plan: Plan = from_str(yaml).expect("should deserialize");
        println!("{plan:#?}");

        let yaml = to_string(&plan).expect("should serialize");
        let plan2: Plan = from_str(&yaml).expect("should deserialize back");

        assert_eq!(plan, plan2, "deserialized structs should be the same");
    }

    #[tokio::test]
    #[traced_test]
    async fn test_spawn_container() {
        use serde_yaml::from_str;

        let yaml = r#"
            steps:
            - spawnContainer:
                name: bash
                image: bash
                cmd: sleep infinity
            - host:
                script: |
                    echo hello
                    echo goodbye
                failure: exploitFailure
            - container:
                name: bash
                shell: /bin/bash -c
                script: |
                    echo hello
                    echo goodbye
                failure: exploitFailure
                success: exploitSuccess
            "#;

        let plan: Plan = from_str(yaml).expect("should deserialize");
        let status = plan.run().await;
        assert!(matches!(status, ExploitStatus::ExploitSuccess));
    }
}
