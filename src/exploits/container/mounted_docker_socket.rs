// SPDX-License-Identifier: Apache-2.0
//
// Houdini  A container escape artist
// Copyright (c) 2022  William Findlay
//
// February 25, 2022  William Findlay  Created this.
//

use std::{os::unix::prelude::FileTypeExt, path::PathBuf};

use docker_api::Docker;
use jwalk::{DirEntry, WalkDir};

use super::{Exploit, ExploitStatus};

/// An exploit that targets a mounted docker docket inside a container.
#[derive(Debug)]
pub struct MountedDockerSocket {
    pub docker_socket_location: PathBuf,
    pub status: Option<ExploitStatus>,
}

#[async_trait]
impl Exploit for MountedDockerSocket {
    async fn run(&self) {
        if let Some(socket) = find_docker_socket().await {
            // TODO
        }
    }

    async fn verify(&self) -> ExploitStatus {
        ExploitStatus::ContainerEscape // FIXME: implement me
    }
}

/// Attempts to find a mounted Docker socket in the container's filesystem.
async fn find_docker_socket() -> Option<PathBuf> {
    for entry in WalkDir::new("/").into_iter().filter_map(Result::ok) {
        if test_docker_sock(&entry).await {
            tracing::info!(path = debug(&entry.path()), "Found mounted docker.sock");
            return Some(entry.path());
        }
    }
    tracing::info!("Failed to find mounted docker.sock");
    return None;
}

/// Tests a file to see if it is a Docker socket.
async fn test_docker_sock(entry: &DirEntry<((), ())>) -> bool {
    if entry.file_type().is_socket() {
        let client = Docker::unix(&entry.path());
        if let Ok(_) = client.ping().await {
            return true;
        }
        return false;
    }

    false
}
