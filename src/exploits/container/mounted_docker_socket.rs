// SPDX-License-Identifier: Apache-2.0
//
// Houdini  A container escape artist
// Copyright (c) 2022  William Findlay
//
// February 25, 2022  William Findlay  Created this.
//

use std::{os::unix::prelude::FileTypeExt, path::PathBuf};

use jwalk::{DirEntry, WalkDir};
use tracing::instrument;

use super::{Exploit, ExploitStatus};

/// An exploit that targets a mounted docker docket inside a container.
#[derive(Debug)]
pub struct MountedDockerSocket {
    pub docker_socket_location: PathBuf,
    pub status: Option<ExploitStatus>,
}

impl Exploit for MountedDockerSocket {
    #[instrument(level = "debug")]
    fn run(&self) {
        if let Some(socket) = find_docker_socket() {
            // TODO
        }
    }

    #[instrument(level = "debug")]
    fn verify(&self) -> ExploitStatus {
        tracing::debug!("Verifying exploit...");
        todo!()
    }
}

/// Attempts to find a mounted Docker socket in the container's filesystem.
fn find_docker_socket() -> Option<PathBuf> {
    for entry in WalkDir::new("/").into_iter().filter_map(Result::ok) {
        if test_docker_sock(&entry) {
            tracing::info!(path = debug(&entry.path()), "Found mounted docker.sock");
            return Some(entry.path());
        }
    }
    tracing::info!("Failed to find mounted docker.sock");
    return None;
}

/// Tests a file to see if it is a Docker socket.
fn test_docker_sock(entry: &DirEntry<((), ())>) -> bool {
    if entry.file_type().is_socket() {
        return true;
    }

    false
}
