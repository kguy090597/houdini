// SPDX-License-Identifier: Apache-2.0
//
// Houdini  A container escape artist
// Copyright (c) 2022  William Findlay
//
// February 25, 2022  William Findlay  Created this.
//

//! This module comprises the various container exploits avaible to Houdini.

mod mounted_docker_socket;

use anyhow::Result;
use clap_derive::ArgEnum;
use tracing::instrument;

use mounted_docker_socket::MountedDockerSocket;

/// Container exploits implement this trait to define the exploit payload and status
/// checks for determining success or failure.
#[async_trait]
pub trait Exploit: std::fmt::Debug {
    async fn run(&self);
    async fn verify(&self) -> ExploitStatus;
}

/// Represents the status of an exploit after it has been run.
#[derive(Debug, Clone)]
pub enum ExploitStatus {
    /// Escape from the container.
    ContainerEscape,
    /// Escape from the container with root privileges.
    ContainerEscapeWithRoot,
    /// A privilegeed action on the host system without container escape.
    HostPrivilegeEscalation,
    /// A privileged action within the container without container escape or host
    /// privilege escalation.
    LocalPrivilegeEscalation,
    /// A failed exploit.
    Failure { reason: String },
}

/// Represents the list of available exploits.
#[derive(Debug, ArgEnum, Clone)]
#[allow(clippy::missing_docs_in_private_items)]
pub enum ExploitKind {
    MountedDockerSocket,
}

impl ExploitKind {
    /// Convert an ExploitKind into the underlying exploit.
    pub fn to_exploit(&self) -> impl Exploit {
        match self {
            ExploitKind::MountedDockerSocket => MountedDockerSocket {
                docker_socket_location: "/var/run/docker.sock".into(),
                status: None,
            },
        }
    }
}

/// Run an exploit inside a container.
#[instrument(level = "debug")]
pub async fn run_exploit(kind: ExploitKind) -> Result<ExploitStatus> {
    let exploit = kind.to_exploit();
    tracing::info!(exploit = debug(&exploit), "Running exploit...");
    exploit.run().await;

    tracing::info!(exploit = debug(&exploit), "Verifying exploit...");
    let status = exploit.verify().await;
    if let ExploitStatus::Failure { reason } = &status {
        tracing::warn!(
            exploit = debug(&exploit),
            reason = debug(&reason),
            "Exploit failed"
        )
    } else {
        tracing::info!(
            exploit = debug(&exploit),
            status = debug(&status),
            "Exploit succeeded"
        )
    }
    Ok(status)
}
