// SPDX-License-Identifier: Apache-2.0
//
// Houdini  A container escape artist
// Copyright (c) 2022  William Findlay
//
// February 25, 2022  William Findlay  Created this.
//

use std::path::PathBuf;

use anyhow::Result;
use docker_api::{api::ContainerCreateOpts, Docker};
use procfs::process::Process;

use crate::exploits::container::ExploitStrategy;

use super::container::{Exploit, ExploitStatus};

/// Find the path to our own executable
fn find_self_exe() -> Result<PathBuf> {
    Process::myself()?.exe().map_err(anyhow::Error::from)
}

async fn spawn_victim_container(
    exploit_strategy: &ExploitStrategy,
    victim_name: &str,
    docker_socket: &str,
    image: &str,
) -> Result<String> {
    let exploit = exploit_strategy.to_exploit();
    let client = Docker::unix(docker_socket);

    // Configure volumes
    let self_exe_volume = format!("{}:/houdini", find_self_exe()?.to_string_lossy());
    let mut volumes = vec![self_exe_volume.as_str()];
    let exploit_volumes = exploit.volumes();
    volumes.extend(exploit_volumes.iter().map(|s| s.as_str()));

    // Spawn the victim container
    let opts_builder = ContainerCreateOpts::builder(image)
        .name(victim_name)
        .volumes(&volumes)
        .tty(true)
        .auto_remove(true);
    //let opts_builder = exploit.apply_container_options(ContainerCreateOpts);
    let create_opts = opts_builder.build();
    let container = client.containers().create(&create_opts).await?;

    // Start the victim container
    container.start().await?;

    Ok(container.id().to_owned())
}

pub async fn run_exploits(exploits: &[ExploitStrategy]) -> Result<Vec<ExploitStatus>> {
    todo!()
}
